//--- PROJECT STRUCTURE ---

cms-waterpark-simulator
    ├── .strapi
    |   └── client
    |       ├── app.js
    |       └── index.html
    ├── config
    |   ├── admin.ts
    |   ├── api.ts
    |   ├── database.ts
    |   ├── middlewares.ts
    |   ├── plugins.ts
    |   └── server.ts
    ├── database
    |   └── migrations
    |       └── .gitkeep
    ├── public
    |   ├── uploads
    |   |   └── .gitkeep
    |   └── robots.txt
    ├── src
    |   ├── admin
    |   |   ├── app.example.tsx
    |   |   ├── tsconfig.json
    |   |   └── vite.config.example.ts
    |   ├── api
    |   |   ├── subcriber
    |   |   |   ├── content-types
    |   |   |   |   └── subcriber
    |   |   |   |       └── schema.json
    |   |   |   ├── controllers
    |   |   |   |   └── subcriber.ts
    |   |   |   ├── routes
    |   |   |   |   └── subcriber.ts
    |   |   |   └── services
    |   |   |       ├── custom-subcriber.ts
    |   |   |       └── subcriber.ts
    |   |   └── .gitkeep
    |   ├── extensions
    |   |   └── .gitkeep
    |   └── index.ts
    ├── types
    |   └── generated
    |       ├── components.d.ts
    |       └── contentTypes.d.ts
    ├── .env
    ├── .env.example
    ├── .strapi-updater.json
    ├── combined_prompt.txt
    ├── favicon.png
    ├── license.txt
    ├── package.json
    ├── README.md
    └── tsconfig.json


//--- FILE CONTENTS ---

//--- FILE: package.json ---

{
  "name": "cms-waterpark-simulator",
  "version": "0.1.0",
  "private": true,
  "description": "A Strapi application",
  "scripts": {
    "build": "strapi build",
    "console": "strapi console",
    "deploy": "strapi deploy",
    "dev": "strapi develop",
    "develop": "strapi develop",
    "start": "strapi start",
    "strapi": "strapi",
    "upgrade": "npx @strapi/upgrade latest",
    "upgrade:dry": "npx @strapi/upgrade latest --dry"
  },
  "dependencies": {
    "@strapi/plugin-cloud": "5.21.0",
    "@strapi/plugin-users-permissions": "5.21.0",
    "@strapi/strapi": "5.21.0",
    "mysql2": "3.9.8",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-router-dom": "^6.0.0",
    "styled-components": "^6.0.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "typescript": "^5"
  },
  "engines": {
    "node": ">=18.0.0 <=22.x.x",
    "npm": ">=6.0.0"
  },
  "strapi": {
    "uuid": "980db6a8-d8e6-4ec9-a84a-0b86321206f6",
    "installId": "d9e25681a9286193a19a7cb162564b63b6538032dc604d5d4ae60154bae2e315"
  }
}


//--- END OF FILE: package.json ---

//--- FILE: src/api/.gitkeep ---



//--- END OF FILE: src/api/.gitkeep ---

//--- FILE: src/api/subcriber/controllers/subcriber.ts ---

/**
 * subcriber controller
 */

import { factories } from '@strapi/strapi';
import { Context } from 'koa';

export default factories.createCoreController('api::subcriber.subcriber', ({ strapi }) => ({

    /**
     * API 1: Xử lý việc đăng ký mới.
     */
    async subscribe(ctx: Context) {
        const { email, 'cf-turnstile-response': captchaToken } = ctx.request.body;

        // --- 1. Validate Input ---
        if (!email) {
            return ctx.badRequest('Email is required.', { errorCode: 'EMAIL_REQUIRED' });
        }
        if (!captchaToken) {
            return ctx.badRequest('Captcha validation is required.', { errorCode: 'CAPTCHA_REQUIRED' });
        }

        // --- 2. Verify Cloudflare Turnstile Captcha ---
        const secretKey = process.env.CLOUDFLARE_TURNSTILE_SECRET_KEY;
        const formData = new FormData();
        formData.append('secret', secretKey);
        formData.append('response', captchaToken);

        try {
            const response = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
                method: 'POST',
                body: formData,
            });
            const outcome = await response.json();
            if (!outcome.success) {
                strapi.log.warn('Captcha verification failed', outcome['error-codes']);
                return ctx.badRequest('Invalid captcha.', { errorCode: 'CAPTCHA_INVALID' });
            }
        } catch (error) {
            strapi.log.error('Error verifying captcha', error);
            return ctx.internalServerError('Could not verify captcha.', { errorCode: 'CAPTCHA_VERIFY_ERROR' });
        }

        // --- 3. Process Subscription Logic ---
        const customSubscriberService = strapi.service('api::subcriber.custom-subcriber');

        try {
            const existingSubscriber = await strapi.db.query('api::subcriber.subcriber').findOne({ where: { email } });

            // Case 1: Đã đăng ký và active
            if (existingSubscriber && existingSubscriber.subscriptionState === 'subscribed') {
                return ctx.badRequest('This email is already subscribed.', { errorCode: 'EMAIL_ALREADY_SUBSCRIBED' });
            }

            // Case 2: Đang chờ xác nhận và chưa hết thời gian cooldown
            if (existingSubscriber && existingSubscriber.subscriptionState === 'pending') {
                const cooldownMinutes = parseInt(process.env.SUBSCRIBE_COOLDOWN_MINUTES, 10) || 5;
                const lastAttemptTime = new Date(existingSubscriber.updatedAt);
                const cooldownTime = new Date(lastAttemptTime.getTime() + cooldownMinutes * 60000);

                if (new Date() < cooldownTime) {
                    return ctx.badRequest(`Please wait ${cooldownMinutes} minutes before trying again.`, { errorCode: 'PENDING_SUBSCRIPTION_COOL_DOWN' });
                }
            }

            // Case 3: Đăng ký mới hoặc đăng ký lại
            const token = customSubscriberService.generateToken();
            const tokenExpiresDays = parseInt(process.env.CONFIRMATION_TOKEN_EXPIRES_DAYS, 10) || 7;
            const tokenExpiresAt = new Date();
            tokenExpiresAt.setDate(tokenExpiresAt.getDate() + tokenExpiresDays);

            const entryData = {
                email,
                subscriptionState: 'pending',
                confirmationToken: token,
                tokenExpiresAt: tokenExpiresAt.toISOString(),
                subscribedAt: null,
                confirmationAt: null,
                unsubscribedAt: null,
            };

            let entry;
            if (existingSubscriber) {
                entry = await strapi.entityService.update('api::subcriber.subcriber', existingSubscriber.id, { data: entryData });
            } else {
                entry = await strapi.entityService.create('api::subcriber.subcriber', { data: entryData });
            }

            // Gửi email xác nhận
            await customSubscriberService.sendConfirmationEmail(entry);

            return ctx.send({
                message: 'Subscription request received. Please check your email to confirm.'
            });

        } catch (error) {
            strapi.log.error('Subscription error:', error);
            // Xử lý lỗi unique constraint của DB
            if (error.code === '23505' || (error.message && error.message.includes('UNIQUE constraint'))) {
                return ctx.badRequest('This email is already subscribed or pending confirmation.', { errorCode: 'EMAIL_ALREADY_SUBSCRIBED' });
            }
            return ctx.internalServerError('An error occurred during the subscription process.');
        }
    },

    /**
     * API 2: Xác nhận đăng ký từ email.
     */
    async confirm(ctx: Context) {
        const { token } = ctx.query;

        if (!token) {
            return ctx.badRequest('Confirmation token is missing.', { errorCode: 'TOKEN_MISSING' });
        }

        const subscriber = await strapi.db.query('api::subcriber.subcriber').findOne({
            where: { confirmationToken: token as string },
        });

        if (!subscriber) {
            return ctx.badRequest('Invalid confirmation token.', { errorCode: 'TOKEN_INVALID' });
        }

        if (new Date(subscriber.tokenExpiresAt) < new Date()) {
            return ctx.badRequest('Confirmation token has expired.', { errorCode: 'TOKEN_EXPIRED' });
        }

        const now = new Date();
        await strapi.entityService.update('api::subcriber.subcriber', subscriber.id, {
            data: {
                subscriptionState: 'subscribed',
                confirmationAt: now.toISOString(),
                subscribedAt: now.toISOString(),
                confirmationToken: null, // Xóa token sau khi xác nhận
                tokenExpiresAt: null,
            },
        });

        return ctx.send({ message: 'Your subscription has been confirmed. Thank you!' });
    },

    /**
     * API 3: Hủy đăng ký.
     */
    async unsubscribe(ctx: Context) {
        const { email } = ctx.query;

        if (!email) {
            return ctx.badRequest('Email is required to unsubscribe.', { errorCode: 'EMAIL_REQUIRED' });
        }

        const subscriber = await strapi.db.query('api::subcriber.subcriber').findOne({
            where: { email: email as string },
        });

        if (!subscriber) {
            // Trả về thành công ngay cả khi không tìm thấy email để tránh lộ thông tin
            return ctx.send({ message: 'If this email exists in our system, it has been unsubscribed.' });
        }

        if (['pending', 'subscribed'].includes(subscriber.subscriptionState)) {
            await strapi.entityService.update('api::subcriber.subcriber', subscriber.id, {
                data: {
                    subscriptionState: 'unsubscribed',
                    unsubscribedAt: new Date().toISOString(),
                    confirmationToken: null,
                    tokenExpiresAt: null,
                },
            });
        }

        return ctx.send({ message: 'You have been successfully unsubscribed.' });
    },
}));


//--- END OF FILE: src/api/subcriber/controllers/subcriber.ts ---

//--- FILE: src/api/subcriber/routes/subcriber.ts ---

/**
 * subcriber router
 */
export default {
    routes: [
        {
            method: 'POST',
            path: '/subscribers/subscribe',
            handler: 'subcriber.subscribe',
            config: {
                auth: false, // Cho phép truy cập công khai
            },
        },
        {
            method: 'GET',
            path: '/subscribers/confirm',
            handler: 'subcriber.confirm',
            config: {
                auth: false,
            },
        },
        {
            method: 'GET',
            path: '/subscribers/unsubscribe',
            handler: 'subcriber.unsubscribe',
            config: {
                auth: false,
            },
        },
        // Bạn có thể giữ lại các routes mặc định nếu cần
        // hoặc xóa chúng đi nếu chỉ sử dụng các custom routes trên.
        {
            method: 'GET',
            path: '/subcribers',
            handler: 'subcriber.find',
        },
        {
            method: 'GET',
            path: '/subcribers/:id',
            handler: 'subcriber.findOne',
        },
        {
            method: 'POST',
            path: '/subcribers',
            handler: 'subcriber.create',
        },
        {
            method: 'PUT',
            path: '/subcribers/:id',
            handler: 'subcriber.update',
        },
        {
            method: 'DELETE',
            path: '/subcribers/:id',
            handler: 'subcriber.delete',
        },
    ],
};


//--- END OF FILE: src/api/subcriber/routes/subcriber.ts ---

//--- FILE: src/api/subcriber/services/custom-subcriber.ts ---

import crypto from 'crypto';

export default ({ strapi }: { strapi }) => ({
    /**
     * Gửi email xác nhận đăng ký.
     * @param {object} subscriber - Đối tượng người đăng ký.
     */
    async sendConfirmationEmail(subscriber) {
        const { email, confirmationToken } = subscriber;
        const frontendUrl = process.env.FRONTEND_URL;

        if (!frontendUrl) {
            strapi.log.error("FRONTEND_URL is not set in the environment variables.");
            return;
        }

        const confirmationLink = `${frontendUrl}/subscribers/confirmation?token=${confirmationToken}`;
        const unsubscribeLink = `${frontendUrl}/subscribers/unsubscribe?email=${encodeURIComponent(email)}`;

        try {
            await strapi.plugin('email').service('email').send({
                to: email,
                from: process.env.EMAIL_FROM,
                replyTo: process.env.EMAIL_REPLY_TO,
                subject: 'Xác nhận đăng ký nhận bản tin',
                html: `
          <h1>Chào mừng bạn!</h1>
          <p>Cảm ơn bạn đã đăng ký nhận bản tin của chúng tôi. Vui lòng nhấp vào liên kết bên dưới để xác nhận địa chỉ email của bạn:</p>
          <a href="${confirmationLink}" target="_blank">Xác nhận đăng ký</a>
          <p>Liên kết này sẽ hết hạn sau ${process.env.CONFIRMATION_TOKEN_EXPIRES_DAYS || 7} ngày.</p>
          <hr>
          <p>Nếu bạn không yêu cầu đăng ký này, vui lòng bỏ qua email này.</p>
          <p>Để hủy đăng ký trong tương lai, bạn có thể truy cập: <a href="${unsubscribeLink}">hủy đăng ký</a>.</p>
        `,
            });
            strapi.log.info(`Confirmation email sent to ${email}`);
        } catch (err) {
            strapi.log.error(`Failed to send confirmation email to ${email}`, err);
        }
    },

    /**
     * Tạo một token ngẫu nhiên và an toàn.
     * @returns {string} Token.
     */
    generateToken() {
        return crypto.randomBytes(32).toString('hex');
    }
});

//--- END OF FILE: src/api/subcriber/services/custom-subcriber.ts ---

//--- FILE: src/api/subcriber/services/subcriber.ts ---

/**
 * subcriber service
 */

import { factories } from '@strapi/strapi';

export default factories.createCoreService('api::subcriber.subcriber');


//--- END OF FILE: src/api/subcriber/services/subcriber.ts ---

//--- FILE: src/api/subcriber/content-types/subcriber/schema.json ---

{
  "kind": "collectionType",
  "collectionName": "subcribers",
  "info": {
    "singularName": "subcriber",
    "pluralName": "subcribers",
    "displayName": "Subcriber"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "email": {
      "type": "email",
      "required": true,
      "unique": true
    },
    "confirmationToken": {
      "type": "string"
    },
    "confirmationAt": {
      "type": "datetime"
    },
    "tokenExpiresAt": {
      "type": "datetime"
    },
    "subscribedAt": {
      "type": "datetime"
    },
    "unsubscribedAt": {
      "type": "datetime"
    },
    "subscriptionState": {
      "type": "enumeration",
      "enum": [
        "pending",
        "subscribed",
        "unsubscribed"
      ]
    },
    "source": {
      "type": "string"
    }
  }
}


//--- END OF FILE: src/api/subcriber/content-types/subcriber/schema.json ---

